{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[{"id":"dc5db7b78df6","title":"运行流程","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"id":"4aa0d5921e31","title":"1.Driver向资源管理器（如YARN）注册并申请运行Executor资源","parent":"dc5db7b78df6","children":[]},{"id":"2310de6c5a86","title":"2.资源管理器分配Executor资源，启动StandaloneExecutorBackend，Executor运行情况将随着心跳发送到资源管理器上","children":[],"parent":"dc5db7b78df6"},{"id":"9df5c8c28929","title":"3.Driver构建成DAG图，将DAG图分解成Stage","children":[],"parent":"dc5db7b78df6"},{"id":"0c345bda2fc3","title":"4.Driver把Taskset发送给TaskScheduler","children":[],"parent":"dc5db7b78df6"},{"id":"66aebb9c63b5","title":"5.Executor向SparkContext申请Task","parent":"dc5db7b78df6","children":[]},{"id":"e53dff3fcfdf","title":"6.运行完毕，释放所有资源","children":[],"parent":"dc5db7b78df6"}],"parent":"root"},{"id":"5d3946c17f0d","title":"架构","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"id":"d3497ec651d3","title":"master","parent":"5d3946c17f0d","children":[{"id":"e4d765657e61","title":"管理集群和节点","children":[],"parent":"d3497ec651d3"}]},{"id":"0289ce851afc","title":"worker","children":[{"id":"b22ff4c404db","title":"与master通信","children":[],"parent":"0289ce851afc"},{"id":"ee5d1fcb09f7","title":"管理、调度自己的executor进程","children":[],"parent":"0289ce851afc"}],"parent":"5d3946c17f0d"},{"id":"89cb88b60c4c","title":"DAGScheduler","parent":"5d3946c17f0d","children":[{"id":"5dbba766cba3","title":"划分stage（taskset）","parent":"89cb88b60c4c","children":[]},{"id":"a8de191f7f1a","title":"重新提交失败的shuffle","children":[],"parent":"89cb88b60c4c"}]},{"id":"2a62645c906c","title":"TaskScheduler","children":[{"id":"0bacf47d2c74","title":"将taskset提交到集群","children":[],"parent":"2a62645c906c"},{"id":"378a62e8094e","title":"汇报计算结果","children":[],"parent":"2a62645c906c"}],"parent":"5d3946c17f0d"}],"parent":"root"},{"id":"5ef45c787b6d","title":"内存","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"id":"89c0195a212e","title":"executor（JVM进程）","parent":"5ef45c787b6d","children":[{"id":"143d65c241d3","title":"堆内内存","parent":"89c0195a212e","children":[{"id":"b1a076cc89b6","title":"统一内存（占比0.6）","parent":"143d65c241d3","children":[{"id":"e6db40c5dc80","title":"storage（占比0.5）","parent":"b1a076cc89b6","children":[{"id":"bc35bfe5be60","title":"存储cache、broadcast等数据","parent":"e6db40c5dc80","children":[]},{"id":"c6c7ac783e07","title":"unroll内存（将partition不连续的内存转换为连续内存）","parent":"e6db40c5dc80","children":[]}]},{"id":"a3d5853253b5","title":"execution（可动态占用，无法占用则借用磁盘）","parent":"b1a076cc89b6","children":[{"id":"434e39c383a8","title":"存储map、shuffle、join、sort、aggregate等过程产生的中间数据","parent":"a3d5853253b5","children":[]}]}]},{"id":"99bbff628378","title":"other（占比0.4）","parent":"143d65c241d3","children":[{"id":"3e924ca16f87","title":"用户自定义数据结构","parent":"99bbff628378","children":[]},{"id":"3eb53f072af4","title":"spark内部元数据","parent":"99bbff628378","children":[]}]},{"id":"cb8b95b2efd6","title":"system reserved","parent":"143d65c241d3","children":[{"id":"7a34a13c6aa2","title":"额外空间保障","parent":"cb8b95b2efd6","children":[]}]}]},{"id":"db4f444fcf7b","title":"堆外内存","parent":"89c0195a212e","children":[{"id":"601894ba4a65","title":"1","parent":"db4f444fcf7b","children":[{"id":"f2ab6892390e","title":"jvm自身、字符串、nio buffer等开销","parent":"601894ba4a65","children":[]}]},{"id":"b3880fa16cb5","title":"2（默认不启用）","parent":"db4f444fcf7b","children":[{"id":"819f1761f2a5","title":"存储经过序列化的二进制数据，可以被精确地申请和释放，而且序列化的数据占用的空间可以被精确计算","parent":"b3880fa16cb5","children":[]}]}]}]}],"parent":"root"},{"id":"688f5a4728fe","title":"优化","lineStyle":{"randomLineColor":"#BE49C4"},"parent":"root","children":[{"id":"5ddce1e71142","title":"OOM","parent":"688f5a4728fe","children":[{"id":"74baf2a69fb7","title":"使用mapPartitons","children":[{"id":"459c9bad54a6","title":"将RDD大量的操作写在一起，避免产生大量的中间rdd对象","children":[],"parent":"74baf2a69fb7"}],"parent":"5ddce1e71142"},{"id":"ec2647581843","title":"产生原因及解决办法","parent":"5ddce1e71142","children":[{"id":"95dbba60d091","title":"map（单个map产生大量对象）","children":[{"id":"b6479e358771","title":"在可能产生大量对象的map操作前使用repartition增加rdd分区，将rdd分为更小的块执行map","parent":"95dbba60d091","children":[]}],"parent":"ec2647581843"},{"id":"dee25167c4a1","title":"coalesce","parent":"ec2647581843","children":[{"id":"b3640ca3bdb3","title":"没有shuffle，可能会导致前面rdd分区也被调整，造成单个分区内存过大","children":[],"parent":"dee25167c4a1"}]},{"id":"5984ca0a2625","title":"shuffle","parent":"ec2647581843","children":[{"id":"0d91b048a748","title":"shuffle过后分区内存过大，在partitioner中增加分区数量","children":[],"parent":"5984ca0a2625"}]}]}]},{"id":"910d9bd54fdd","title":"代码优化","children":[{"id":"e53f2033918e","title":"broadcast join","parent":"910d9bd54fdd","children":[{"id":"63801371c2b4","title":"相当于mapjoin","parent":"e53f2033918e","children":[]}]},{"id":"858ce3d34b6e","title":"调整persist等级","parent":"910d9bd54fdd","children":[]}],"parent":"688f5a4728fe"},{"id":"620cbc59553d","title":"参数优化","children":[{"id":"2f1d5fbdc92d","title":"spark运行时","parent":"620cbc59553d","children":[{"id":"dc08e747c7d5","title":"设置动态资源分配同一时刻，最多可申请的executor个数（限制最小executor个数）","parent":"2f1d5fbdc92d","children":[]},{"id":"bfd48f80c774","title":"控制分区合并（保证分区数量）","parent":"2f1d5fbdc92d","children":[]}]},{"id":"aad838bc599e","title":"executor","parent":"620cbc59553d","children":[{"id":"4b1811259c4c","title":"增加cpu核数","children":[],"parent":"aad838bc599e"},{"id":"4ba4efea0590","title":"增加内存","children":[],"parent":"aad838bc599e"},{"id":"5667c2b4c439","title":"开启堆外内存","children":[],"parent":"aad838bc599e"}]},{"id":"635088c90721","title":"其他参数","parent":"620cbc59553d","children":[{"id":"63a4a7830715","title":"broadcast join阈值","parent":"635088c90721","children":[]},{"id":"f43f69e5099b","title":"默认task并行数量","parent":"635088c90721","children":[]},{"id":"c96b1b1c8cad","title":"推测执行","parent":"635088c90721","children":[{"id":"4d149def584d","title":"stage中某些运行缓慢的的task，将被重新计算","parent":"c96b1b1c8cad","children":[]}]},{"id":"bb7adc810a52","title":"统计优化","parent":"635088c90721","children":[{"id":"835c64e81e0e","title":"仅使用表的元数据的元数据查询优化来生成分区列，而不是表扫描","parent":"bb7adc810a52","children":[]}]}]},{"id":"0f29f50c99ae","title":"注意：spark.default.parallelism只有在处理RDD时有效，spark.sql.shuffle.partitions则是只对SparkSQL有效","children":[],"parent":"620cbc59553d"}],"parent":"688f5a4728fe"},{"id":"b994e7e492b0","title":"数据倾斜","children":[{"id":"c07749c55b30","title":"问题定位（必然是会产生shuffle的算子处）","children":[{"id":"673a543b5c5f","title":"web ui查看task分配数据量","children":[],"parent":"c07749c55b30"},{"id":"8bbc12a5e964","title":"对key抽样统计","parent":"c07749c55b30","children":[]}],"parent":"b994e7e492b0"},{"id":"07fbf98543dc","title":"解决","parent":"b994e7e492b0","children":[{"id":"f29fd6f315b4","title":"hive etl预处理","parent":"07fbf98543dc","children":[{"id":"a405cb9d3b45","title":"治标不治本，hive可能数据倾斜","parent":"f29fd6f315b4","children":[]}]},{"id":"a386891aa47d","title":"发生倾斜的key很少，过滤","parent":"07fbf98543dc","children":[]},{"id":"c20cd6162bf4","title":"提高shuffle并行度","children":[],"parent":"07fbf98543dc"},{"id":"ee417cb98385","title":"双job","children":[{"id":"c85313517353","title":"加盐局部聚合，去盐全局聚合","children":[],"parent":"ee417cb98385"}],"parent":"07fbf98543dc"},{"id":"daaf26a1a02f","title":"mapjoin","children":[],"parent":"07fbf98543dc"},{"id":"daebcab66101","title":"热点key单独处理","children":[],"parent":"07fbf98543dc"}]}],"parent":"688f5a4728fe"}]}],"title":"spark","watermark":"","root":true,"theme":"delicate_caihong","children":[{"id":"7046303bead5","title":"rdd","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"id":"f2c738476e72","title":"5大属性","children":[{"id":"86dc1b39c52c","title":"rdd是不可变的，每个分片都是1个task","children":[],"parent":"f2c738476e72"},{"id":"32bed9d30b0b","title":"分区计算函数compute会对迭代器进行复合，无需保存每次计算结果","parent":"f2c738476e72","children":[]},{"id":"697c173b142b","title":"rdd依赖，容错","children":[],"parent":"f2c738476e72"},{"id":"17908c2881ef","title":"hash分区和range分区，决定数据去向","children":[],"parent":"f2c738476e72"},{"id":"8d65f6426c13","title":"移动数据不如移动计算","parent":"f2c738476e72","children":[]}],"parent":"7046303bead5"},{"id":"4d32214297d1","title":"算子","parent":"7046303bead5","children":[{"id":"70afc612d1aa","title":"类型","children":[{"id":"531c590c639a","title":"transform","parent":"70afc612d1aa","children":[{"id":"c6df58363b71","title":"map、filter、flatMap、groupByKey、reduceByKey（combiner）、aggregateByKey、union、join、coalesce","children":[],"parent":"531c590c639a"}]},{"id":"494c07a88990","title":"action（执行之后数据类型不再是rdd）","children":[{"id":"770a61857975","title":"reduce、collect、foreach、count、first、take、countByKey","parent":"494c07a88990","children":[]}],"parent":"70afc612d1aa"}],"parent":"4d32214297d1"},{"id":"6dbf5cf3ea76","title":"coalesce与repartition的区别","children":[{"id":"23586b52e922","title":"repartition底层调用coalesce，一定会shuffle，可增加分区","children":[],"parent":"6dbf5cf3ea76"},{"id":"11e60c7d80ce","title":"coalesce根据参数决定是否shuffle，只能减少分区","parent":"6dbf5cf3ea76","children":[]}],"parent":"4d32214297d1"},{"id":"bae67587a1c9","title":"sortBy和sortByKey的区别","children":[{"id":"bf5f05e21c13","title":"sortBy既可以作用于RDD[K] ，还可以作用于RDD[(k,v)]","children":[],"parent":"bae67587a1c9"},{"id":"84993433efc1","title":"sortByKey只能作用于 RDD[K,V] 类型上","children":[],"parent":"bae67587a1c9"}],"parent":"4d32214297d1"}]},{"id":"ec24f453d0a2","title":"缓存","children":[{"id":"f6f7c67a9e01","title":"缓存级别","parent":"ec24f453d0a2","children":[{"id":"ff9695a5329e","title":"内存","children":[],"parent":"f6f7c67a9e01"},{"id":"084a934eb26b","title":"磁盘","children":[{"id":"37764e30ffb1","title":"尽量不存储到硬盘上，除非计算数据集的函数，计算量特别大，或者它们过滤了大量的数据。否则，重新计算一个分区的速度，和与从硬盘中读取基本差不多","children":[],"parent":"084a934eb26b"}],"parent":"f6f7c67a9e01"},{"id":"3c07d3f6a610","title":"复制","parent":"f6f7c67a9e01","children":[{"id":"583c218fdfda","title":"在其他节点会保存一份rdd备份，可持续运行任务，不需要等待丢失的分区被重新计算","children":[],"parent":"3c07d3f6a610"}]}]},{"id":"f6c6e20f369a","title":"缓存类型","parent":"ec24f453d0a2","children":[{"id":"82c2938108fc","title":"cache","parent":"f6c6e20f369a","children":[{"id":"4518862cffcc","title":"执行action后将数据写入（每个executor的）内存或磁盘中，保存rdd依赖关系","children":[],"parent":"82c2938108fc"}]},{"id":"b20ab2330f08","title":"checkpoint","parent":"f6c6e20f369a","children":[{"id":"8b7b954e4025","title":"执行action后将数据写入hdfs中，不保存rdd依赖关系","children":[],"parent":"b20ab2330f08"}]}]}],"parent":"7046303bead5"},{"id":"2846dcfb43bd","title":"宽窄依赖","children":[{"id":"3b8aec798483","title":"窄依赖","children":[],"parent":"2846dcfb43bd"},{"id":"13aa3d5bf835","title":"宽依赖（父RDD的一个分区中的数据有可能被分配到子RDD的多个分区中）","children":[{"id":"1c00dee05215","title":"groupByKey、reduceByKey、sortByKey<br>","children":[],"parent":"13aa3d5bf835"}],"parent":"2846dcfb43bd"}],"parent":"7046303bead5"}],"parent":"root"},{"id":"4194e0e15a23","title":"技术","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"id":"3ebe55a6be98","title":"广播变量","children":[{"id":"19cfe851404c","title":"只读，由每个task一份变为每个executor一份，减少网络传输","children":[],"parent":"3ebe55a6be98"}],"parent":"4194e0e15a23"},{"id":"e243bf251cb4","title":"累加器","parent":"4194e0e15a23","children":[{"id":"6ddcf0b86d9f","title":"分布式计数","parent":"e243bf251cb4","children":[]}]}],"parent":"root"},{"id":"cff9be7566df","title":"其他","lineStyle":{"randomLineColor":"#DD489D"},"parent":"root","children":[{"id":"5c10d8b4e81e","title":"stage如何划分？","parent":"cff9be7566df","children":[{"id":"f7c377b7cbfb","title":"宽依赖","children":[],"parent":"5c10d8b4e81e"}]},{"id":"f724b6525ae6","title":"Partition的数量由什么决定？","parent":"cff9be7566df","children":[{"id":"d286559e6d84","title":"默认可用cpu核数","children":[],"parent":"f724b6525ae6"}]},{"id":"1a493e7a48ed","title":"Sparkcontext的作用？","parent":"cff9be7566df","children":[]},{"id":"95d222250744","title":"Sparkstreaming读取kafka数据为什么选择直连方式？","parent":"cff9be7566df","children":[]},{"id":"3893dd08bb68","title":"Sparkstreaming实时的数据如何不丢失？","children":[{"id":"7db2ec89aebd","title":"kafka直连 + checkpoint","children":[],"parent":"3893dd08bb68"}],"parent":"cff9be7566df"},{"id":"7cece00c0e3b","title":"特别大的数据，怎么发送到excutor中？","parent":"cff9be7566df","children":[{"id":"ba814903b642","title":"行切分，分别读取","parent":"7cece00c0e3b","children":[]},{"id":"6d172ec22e66","title":"切分成k、v形式，join","children":[],"parent":"7cece00c0e3b"}]},{"id":"0391716724cb","title":"spark streaming如何实现Exactly-Once？","children":[],"parent":"cff9be7566df"},{"id":"597778c446bd","title":"怎么实时查看用户访问数?这种实时变动的需求怎么实现?","parent":"cff9be7566df","children":[]},{"id":"35ae672383f4","title":"spark为什么比mapreduce快？","children":[{"id":"863559e597e2","title":"并行（多个stage）计算","children":[],"parent":"35ae672383f4"},{"id":"f3f0b6dcef9e","title":"内存计算","children":[],"parent":"35ae672383f4"}],"parent":"cff9be7566df"},{"id":"d3ccde2905af","title":"sparksql与hive的区别？","children":[],"parent":"cff9be7566df"}]},{"id":"bf8d08c8adea","title":"其他集成","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"id":"73cabb7f3d05","title":"spark streaming连接kafka","children":[{"id":"6280f6707465","title":"direct","children":[],"parent":"73cabb7f3d05"},{"id":"67d3c61b1efb","title":"receiver","children":[],"parent":"73cabb7f3d05"}],"parent":"bf8d08c8adea"}],"parent":"root"}],"note":""}},"meta":{"id":"60dd69355653bb2a8d0a0489","member":"5ff295855653bb21c1b7d3b9","exportTime":"2021-07-03 09:51:20","diagramInfo":{"category":"mind_free","title":"spark","created":"2021-07-01 15:05:25","creator":"5ff295855653bb21c1b7d3b9","modified":"2021-07-02 16:40:44"},"type":"ProcessOn Schema File","version":"1.0"}}